package pro.krit.hiveksp.generators

import com.google.devtools.ksp.closestClassDeclaration
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.KotlinPoetKspPreview
import pro.krit.core.data.BindData
import pro.krit.core.extensions.createFileName
import pro.krit.core.extensions.getPackAndClass
import pro.krit.hiveksp.base.BaseDatabaseVisitor
import pro.krit.hiveksp.data.KspData
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.Modifier
import javax.lang.model.type.TypeMirror

@KotlinPoetKspPreview
class DatabaseCodeGenerator(
    logger: KSPLogger,
    codeGenerator: CodeGenerator
) : BaseDatabaseVisitor(logger, codeGenerator) {

    companion object {
        private const val ARG_AS_SINGLETON = "asSingleton"
        private const val ARG_AS_DAO_PROVIDER = "asDaoProvider"

        private const val FMP_DATABASE_NAME = "FmpDatabase"

        private const val DAO_PACKAGE_NAME = "pro.krit.generated.ksp.dao"
        private const val DATABASE_PACKAGE_NAME = "pro.krit.generated.ksp.database"
        private const val REQUEST_PACKAGE_NAME = "pro.krit.generated.ksp.request"

        private const val EXTENSIONS_PATH = "pro.krit.core.extensions"
        private const val QUERY_EXECUTER_PATH = "pro.krit.core.common"
        private const val QUERY_EXECUTER_NAME = "QueryExecuter"

        private const val BASE_FMP_DATABASE_NAME = "AbstractFmpDatabase"
        private const val FMP_DATABASE_ANNOTATION_NAME = "FmpDatabase"
        private const val FMP_FIELDS_DAO_NAME = "FieldsDao"

        private const val INIT_CREATE_TABLE = "createTable"

        private const val REQUEST_STATEMENT = "request"
        private const val REQUEST_NAME = "requestWithParams"
        //private const val REQUEST_ASYNC_STATEMENT = "requestAsync"
        //private const val REQUEST_ASYNC_NAME = "requestWithParamsAsync"

        //private const val FUNC_CREATE_PARAMS_NAME = "createParams"
        private const val FUNC_CREATE_PARAMS_MAP_NAME = "createParamsMap"
        private const val FUNC_GET_PARAMETER_NAME = "getParameterName"

        private const val FMP_DAO_NAME = "FmpDao"
        private const val FMP_LOCAL_DAO_NAME = "FmpLocalDao"
        private const val FMP_BASE_NAME = "IFmpDatabase"

        private const val TAG_MEMBER_FULL = "%M()"
        private const val TAG_MEMBER_HALF = "%M("
        private const val FUNC_MEMBER_STATEMENT = "this.%M()"
        private const val FUNC_MEMBER_PARAMS_STATEMENT = "this.%M"
        private const val FUNC_MEMBER_STATEMENT_GENERIC = "this.%M<"
        private const val FUNC_MEMBER_STATEMENT_GENERIC_CLOSE = ">()"

        private const val FIELD_PROVIDER = "fmpDatabase"
        private const val FIELD_HYPER_HIVE = "hyperHive"
        private const val FIELD_DEFAULT_HEADERS = "defaultHeaders"
        private const val FIELD_RESOURCE_NAME = "resourceName"
        private const val FIELD_TABLE = "tableName"
        private const val FIELD_IS_DELTA = "isDelta"
        private const val FIELD_DAO_FIELDS = "fieldsData"
        private const val FIELD_PARAMS = "params"
        private const val FIELD_PARAMS_REPLACE = "(params = %s)"
        private const val FIELD_PARAMS_GET = "params.getOrNull(%s).orEmpty()"
        //private const val FIELD_PARAMS_GET_NULL = "params.getOrNull(%s)"

        private const val MOBRUN_MODEL_PATH = "com.mobrun.plugin.models"
        private const val MOBRUN_SELECTABLE_NAME = "StatusSelectTable"
        private const val MOBRUN_BASE_NAME = "BaseStatus"

        private const val NULL_INITIALIZER = "null"
        private const val RETURN_STATEMENT = "return"
        private const val TAG_CLASS_NAME = "%T"

        private const val QUERY_VALUE = "val query: String = "
        private const val QUERY_RETURN = "return %T.executeQuery(this, query)"

        private const val PARAMS_COMMENT_FIRST = "This function was autogenerated."
        private const val PARAMS_COMMENT_SECOND =
            " Use annotation field - 'parameters' to add request params"
        private const val PARAMS_COMMENT_THIRD = " Please specify %s vararg param: "
    }

    override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: List<KspData>) {
        logger.warn("---> class name = ${classDeclaration.simpleName.asString()}")

        val firstAnnotation = classDeclaration.annotations.firstOrNull()
        val annotationArgs: List<KSValueArgument> = firstAnnotation?.arguments.orEmpty()
        val isSingleInstance: Boolean = annotationArgs.getArgumentValue(ARG_AS_SINGLETON) ?: false
        val asDaoProvider: Boolean = annotationArgs.getArgumentValue(ARG_AS_DAO_PROVIDER) ?: false
        val className = classDeclaration.simpleName.asString()
        val packName = classDeclaration.packageName.asString()
        val fileName = className.createFileName()

        val superClassName = ClassName(packName, className)
        val classTypeSpec = if (isSingleInstance) {
            TypeSpec.objectBuilder(fileName)
        } else {
            TypeSpec.classBuilder(fileName)
        }
        classTypeSpec.superclass(superClassName)

        // Extended classes only for Interfaces
        createDatabaseExtendedFunction(
            classTypeSpec,
            classDeclaration,
            data,
            asDaoProvider
        )

        saveFiles(DATABASE_PACKAGE_NAME, fileName, listOf(classTypeSpec))
    }

    private fun createDatabaseExtendedFunction(
        classTypeSpec: TypeSpec.Builder,
        element: KSDeclaration,
        daoList: List<KspData>,
        asProvider: Boolean
    ) {
        val extendedTypeMirrors = element.closestClassDeclaration()?.superTypes?.toList()?.map {
            it.resolve().declaration
        }.orEmpty()
        logger.warn("-------> extended = ${extendedTypeMirrors}")
        if (extendedTypeMirrors.isNotEmpty()) {
            val extendedElements = extendedTypeMirrors.mapToInterfaceElements().filter { extElement ->
                !extElement.simpleName.asString().contains(FMP_BASE_NAME)
            }
            logger.warn("----------------> createDatabaseExtendedFunction")
            logger.warn("checkExtendedInterface $element - extendedElements $extendedElements")
            extendedElements.forEach { extendedElement ->
                createFunctions(classTypeSpec, extendedElement, daoList, asProvider)
            }
        }
    }

    private fun createFunctions(
        classTypeSpec: TypeSpec.Builder,
        element: KSDeclaration,
        daoList: List<KspData>,
        asProvide: Boolean = false
    ): List<String> {
        val methods: List<KSFunctionDeclaration> = element.closestClassDeclaration()?.getAllFunctions()?.toList().orEmpty()
        val allPropNames = mutableListOf<String>()
        //println("----------------> createFunctions")
        //println("------> element = $element | enclosedElements = $methods")

        methods.forEach { enclose ->
            if (enclose.isAbstract) {
                val returnType = enclose.returnType
                val returnDeclaration = returnType?.resolve()?.declaration
                val returnPack = returnDeclaration?.packageName?.asString().orEmpty()
                val returnClass = returnDeclaration?.simpleName?.asString().orEmpty()
                val funcName = enclose.simpleName.asString()
                val returnedClass = ClassName(returnPack, returnClass)

                val returnElementData = daoList.find { it.mainData.className == returnClass }


                returnElementData?.let {
                    val instancePackName = if (returnElementData.isRequest) {
                        REQUEST_PACKAGE_NAME
                    } else {
                        DAO_PACKAGE_NAME
                    }
                    val returnedClassName = ClassName(instancePackName, it.fileName)

                    //logger.warn("------> funcName = ${funcName} ")
                    //logger.warn("------> returnedClass = ${it.mainData.className} ")

                    val instanceStatement = if (returnElementData.isRequest) {
                        buildString {
                            append("$TAG_CLASS_NAME(")
                            appendLine()
                            append("$FIELD_HYPER_HIVE = this.provideHyperHive(),")
                            appendLine()
                            append("$FIELD_DEFAULT_HEADERS = this.getDefaultHeaders()")
                            appendLine()
                            append(")")
                        }
                    } else {
                        "$TAG_CLASS_NAME($FIELD_PROVIDER = this)"
                    }
                    val funcSpec = FunSpec.builder(funcName)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(returnedClass).apply {
                            if (asProvide) {
                                addStatement(
                                    "$RETURN_STATEMENT $instanceStatement",
                                    returnedClassName
                                )
                            } else {

                                val propName = funcName.createFileName()
                                allPropNames.add(propName)
                                val prop =
                                    PropertySpec.builder(
                                        propName,
                                        returnedClassName.copy(nullable = true)
                                    )
                                        .mutable()
                                        .addModifiers(KModifier.PRIVATE)
                                        .initializer(NULL_INITIALIZER)
                                        .build()

                                classTypeSpec.addProperty(prop)

                                val statementIf = "if($propName == $NULL_INITIALIZER) "
                                val statementCreate = "$propName = $instanceStatement"
                                val statementReturn = "$RETURN_STATEMENT $propName!!"
                                beginControlFlow(statementIf)
                                addStatement(statementCreate, returnedClassName)
                                endControlFlow()
                                addStatement(statementReturn)
                            }
                        }
                        .build()

                    //logger.warn("-----> func spec = ${funcSpec}")
                    classTypeSpec.addFunction(funcSpec)
                }
            }
        }


        return allPropNames
    }

    // Take extended interfaces for implement abstract methods
    private fun List<KSDeclaration>.mapToInterfaceElements(): List<KSDeclaration> {
        return this.mapNotNull { typeMirror ->
            typeMirror.takeIf {
                val currentClassName = it.toString().getPackAndClass().second
                !currentClassName.contains(BASE_FMP_DATABASE_NAME)
            }
        }
    }


}