package pro.krit.hiveksp.base

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSValueArgument
import com.google.devtools.ksp.symbol.KSVisitorVoid
import com.mobrun.plugin.api.request_assistant.PrimaryKey
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.KotlinPoetKspPreview
import com.squareup.kotlinpoet.ksp.writeTo
import pro.krit.hiveksp.common.Params.CREATE_TABLE_ON_INIT
import pro.krit.hiveksp.common.Params.FIELDS
import pro.krit.hiveksp.common.Params.IS_DELTA
import pro.krit.hiveksp.common.Params.PARAMS
import pro.krit.hiveksp.common.Params.RESOURCE_NAME
import pro.krit.hiveksp.common.Params.TABLE_NAME
import pro.krit.hiveksp.data.KspData
import pro.krit.hiveprocessor.base.IDao
import pro.krit.hiveprocessor.common.DaoFieldsData
import pro.krit.hiveprocessor.data.TypeData
import pro.krit.hiveprocessor.extensions.*
import pro.krit.hiveprocessor.provider.IFmpDatabase
import java.io.IOException

@KotlinPoetKspPreview
abstract class BaseSymbolVisitor(
    protected val logger: KSPLogger,
    private val codeGenerator: CodeGenerator
) : KSVisitorVoid() {

    companion object {

        private const val FMP_DATABASE_NAME = "FmpDatabase"

        private const val DAO_PACKAGE_NAME = "pro.krit.generated.dao"
        private const val DATABASE_PACKAGE_NAME = "pro.krit.generated.database"
        private const val REQUEST_PACKAGE_NAME = "pro.krit.generated.request"

        private const val EXTENSIONS_PATH = "pro.krit.hiveprocessor.extensions"
        private const val QUERY_EXECUTER_PATH = "pro.krit.hiveprocessor.common"
        private const val QUERY_EXECUTER_NAME = "QueryExecuter"

        private const val BASE_FMP_DATABASE_NAME = "AbstractFmpDatabase"
        private const val FMP_DATABASE_ANNOTATION_NAME = "FmpDatabase"
        private const val FMP_FIELDS_DAO_NAME = "FieldsDao"

        private const val INIT_CREATE_TABLE = "createTable"

        private const val REQUEST_STATEMENT = "request"
        private const val REQUEST_NAME = "requestWithParams"
        //private const val REQUEST_ASYNC_STATEMENT = "requestAsync"
        //private const val REQUEST_ASYNC_NAME = "requestWithParamsAsync"

        //private const val FUNC_CREATE_PARAMS_NAME = "createParams"
        private const val FUNC_CREATE_PARAMS_MAP_NAME = "createParamsMap"
        private const val FUNC_GET_PARAMETER_NAME = "getParameterName"

        private const val FMP_DAO_NAME = "FmpDao"
        private const val FMP_LOCAL_DAO_NAME = "FmpLocalDao"
        private const val FMP_BASE_NAME = "IFmpDatabase"

        private const val TAG_MEMBER_FULL = "%M()"
        private const val TAG_MEMBER_HALF = "%M("
        private const val FUNC_MEMBER_STATEMENT = "this.%M()"
        private const val FUNC_MEMBER_PARAMS_STATEMENT = "this.%M"
        private const val FUNC_MEMBER_STATEMENT_GENERIC = "this.%M<"
        private const val FUNC_MEMBER_STATEMENT_GENERIC_CLOSE = ">()"

        private const val FIELD_PROVIDER = "fmpDatabase"
        private const val FIELD_HYPER_HIVE = "hyperHive"
        private const val FIELD_DEFAULT_HEADERS = "defaultHeaders"
        private const val FIELD_RESOURCE_NAME = "resourceName"
        private const val FIELD_TABLE = "tableName"
        private const val FIELD_IS_DELTA = "isDelta"
        private const val FIELD_DAO_FIELDS = "fieldsData"
        private const val FIELD_PARAMS = "params"
        private const val FIELD_PARAMS_REPLACE = "(params = %s)"
        private const val FIELD_PARAMS_GET = "params.getOrNull(%s).orEmpty()"
        //private const val FIELD_PARAMS_GET_NULL = "params.getOrNull(%s)"

        private const val MOBRUN_MODEL_PATH = "com.mobrun.plugin.models"
        private const val MOBRUN_SELECTABLE_NAME = "StatusSelectTable"
        private const val MOBRUN_BASE_NAME = "BaseStatus"

        private const val NULL_INITIALIZER = "null"
        private const val RETURN_STATEMENT = "return"
        private const val TAG_CLASS_NAME = "%T"

        private const val QUERY_VALUE = "val query: String = "
        private const val QUERY_RETURN = "return %T.executeQuery(this, query)"

        private const val FILE_COMMENT =
            "This file was generated by  Do not modify!"

        private const val PARAMS_COMMENT_FIRST = "This function was autogenerated."
        private const val PARAMS_COMMENT_SECOND =
            " Use annotation field - 'parameters' to add request params"
        private const val PARAMS_COMMENT_THIRD = " Please specify %s vararg param: "
    }

    protected fun getKspDataFromAnnotation(element: KSDeclaration): KspData {
        val firstAnnotation = element.annotations.firstOrNull()
        val annotationArgs: List<KSValueArgument> = firstAnnotation?.arguments.orEmpty()
        val resourceName: String = annotationArgs.getArgumentValue<String>(RESOURCE_NAME).orEmpty()
        val tableName: String = annotationArgs.getArgumentValue<String>(TABLE_NAME).orEmpty()
        val fields: List<String> = annotationArgs.getArgumentValue<List<String>>(FIELDS).orEmpty()
        val params: List<String> = annotationArgs.getArgumentValue<List<String>>(PARAMS).orEmpty()
        val createTableOnInit: Boolean = annotationArgs.getArgumentValue(CREATE_TABLE_ON_INIT) ?: false
        val isDelta: Boolean = annotationArgs.getArgumentValue(IS_DELTA) ?: false
        val className = element.simpleName.asString()
        val fileName = className.createFileName()
        
        val shortName = firstAnnotation?.shortName?.asString().orEmpty()
        val isLocal = shortName.contains("local", ignoreCase = true)
        val isRequest = shortName.contains("request", ignoreCase = true)

        return KspData(
            element = element,
            fileName = fileName,
            mainData = TypeData(
                packName = element.packageName.asString(),
                className = className
            ),
            createTableOnInit = createTableOnInit,
            parameters = params,
            fields = fields,
            resourceName = resourceName,
            tableName = tableName,
            isDelta = isDelta,
            isLocal = isLocal,
            isRequest = isRequest
        ).also {
            logger.warn("----> KSP DATA = $it")
        }
    }

    private fun processDaos(moduleElements: List<KspData>) {
        moduleElements.filter { !it.isRequest }.forEach { bindData ->
            val classFileName = bindData.fileName
            val className = bindData.mainData.className
            val packageName = bindData.mainData.packName
            val mainClassName = ClassName(packageName, className)
            val classBuilders = mutableListOf<TypeSpec.Builder>()


            // generics type array for class type
            val genericsArray = mutableListOf<String>()

            val classTypeSpec =
                TypeSpec.classBuilder(classFileName)
                    .addSuperinterface(mainClassName)
                    .addProperties(createProperties())
            classBuilders.add(classTypeSpec)

            if (bindData.parameters.isNotEmpty()) {
                val localParams = bindData.parameters
                val requestFunc = createRequestFunction(localParams)
                classTypeSpec.addFunction(requestFunc.build())
            }

            if (bindData.fields.isNotEmpty()) {
                val fileModelName = className.createFileName(MODEL_POSTFIX)
                val fileStatusName = className.createFileName(STATUS_POSTFIX)

                val modelClass = ClassName(DAO_PACKAGE_NAME, fileModelName)
                val statusClass = ClassName(DAO_PACKAGE_NAME, fileStatusName)
                val statusParentClaas = ClassName(MOBRUN_MODEL_PATH, MOBRUN_SELECTABLE_NAME)
                val modelTypeSpec = TypeSpec.classBuilder(fileModelName)
                val statusTypeSpec = TypeSpec.classBuilder(fileStatusName)
                    .superclass(statusParentClaas.parameterizedBy(modelClass))

                genericsArray.clear()
                genericsArray.add(modelClass.toString())
                genericsArray.add(statusClass.toString())

                val baseClassType = if (bindData.isLocal) {
                    IDao.IFmpLocalDao::class.asTypeName()
                } else {
                    IDao.IFmpDao::class.asTypeName()
                }

                val constructorSpec = FunSpec.constructorBuilder()
                val annotationJvmField = AnnotationSpec.builder(JvmField::class).build()
                val annotationPrimaryKey = AnnotationSpec.builder(PrimaryKey::class).build()

                bindData.fields.forEach { field ->
                    val data = field.asModelFieldData()
                    val annotationSerialize = data.annotate.createSerializedAnnotation()

                    val currentType = data.type.asTypeName().copy(nullable = true)
                    val prop =
                        PropertySpec.builder(data.name, currentType)
                            .mutable(true)
                            .initializer(data.name)
                            .addAnnotation(annotationJvmField)
                            .apply {
                                if (data.isPrimaryKey) {
                                    addAnnotation(annotationPrimaryKey)
                                }
                            }
                            .addAnnotation(annotationSerialize)
                            .build()


                    constructorSpec.addParameter(
                        ParameterSpec.builder(data.name, currentType)
                            .defaultValue(NULL_INITIALIZER)
                            .build()
                    )
                    modelTypeSpec.addProperty(prop)
                }
                modelTypeSpec.primaryConstructor(constructorSpec.build())
                modelTypeSpec.addModifiers(KModifier.DATA)
                classBuilders.add(modelTypeSpec)
                classBuilders.add(statusTypeSpec)

                classTypeSpec.addSuperinterface(
                    baseClassType.parameterizedBy(modelClass, statusClass)
                )
            } else {
                val superInterfaces = bindData.element.findActuals().toList()
                //println("------> superInterfaces = $superInterfaces")
                genericsArray.clear()
                genericsArray.addAll(
                    superInterfaces
                        .map { it.simpleName.asString() }
                        .firstOrNull { it.contains(FMP_DAO_NAME) || it.contains(
                            FMP_LOCAL_DAO_NAME
                        ) }
                        .splitGenericsArray()
                )
            }

            //println("------> genericsArray = $genericsArray")
            // осноыной конструктор с дженериками
            classTypeSpec.primaryConstructor(constructorFunSpec(bindData, genericsArray))

            saveFiles(DAO_PACKAGE_NAME, classFileName, builders = classBuilders)
        }
    }

    // создаем иницилизируешие поля для конструктора а так жу функцию init {  }
    private fun constructorFunSpec(bindData: KspData, superTypeGenerics: List<String>): FunSpec {
        val resourceName = ParameterSpec.builder(FIELD_RESOURCE_NAME, String::class).apply {
            if (bindData.resourceName.isNotEmpty()) {
                defaultValue("\"${bindData.resourceName}\"")
            }
        }.build()

        val parameterName = ParameterSpec.builder(FIELD_TABLE, String::class)
            .defaultValue("\"${bindData.tableName}\"")
            .build()

        val isCached = ParameterSpec.builder(FIELD_IS_DELTA, Boolean::class)
            .defaultValue("${bindData.isDelta}")
            .build()

        val hyperHiveProvider =
            ParameterSpec.builder(FIELD_PROVIDER, IFmpDatabase::class)
                .build()

        return FunSpec.constructorBuilder()
            .addParameter(hyperHiveProvider)
            .addParameter(resourceName)
            .addParameter(parameterName)
            .addParameter(isCached)
            .apply {
                val isLocalProp = ParameterSpec.builder(
                    FIELD_DAO_FIELDS,
                    DaoFieldsData::class.asTypeName().copy(nullable = true)
                )
                    .defaultValue(NULL_INITIALIZER)
                    .build()
                addParameter(isLocalProp)

                //println("--------> superTypeGenerics = $superTypeGenerics")

                if (bindData.createTableOnInit) {
                    val members = mutableListOf<Any>()
                    members.add(MemberName(
                        EXTENSIONS_PATH,
                        INIT_CREATE_TABLE
                    ))
                    val initStatement = buildString {
                        if (superTypeGenerics.isNotEmpty()) {
                            append(FUNC_MEMBER_STATEMENT_GENERIC)
                            val className = superTypeGenerics.firstOrNull().orEmpty()
                            append(className)
                            append(FUNC_MEMBER_STATEMENT_GENERIC_CLOSE)
                        } else {
                            append(FUNC_MEMBER_STATEMENT)
                        }
                    }

                    addStatement(
                        initStatement,
                        MemberName(EXTENSIONS_PATH, INIT_CREATE_TABLE)
                    )
                }
            }
            .build()
    }

    private fun createProperties(): List<PropertySpec> {
        val hyperHiveProviderProp =
            PropertySpec.builder(FIELD_PROVIDER, IFmpDatabase::class)
                .initializer(FIELD_PROVIDER)
                .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
                .build()

        val resourceNameProp = PropertySpec.builder(FIELD_RESOURCE_NAME, String::class)
            .initializer(FIELD_RESOURCE_NAME)
            .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
            .build()

        val parameterNameProp = PropertySpec.builder(FIELD_TABLE, String::class)
            .initializer(FIELD_TABLE)
            .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
            .build()

        val isCachedProp = PropertySpec.builder(FIELD_IS_DELTA, Boolean::class)
            .initializer(FIELD_IS_DELTA)
            .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
            .build()

        val isLocalProp = PropertySpec.builder(
            FIELD_DAO_FIELDS,
            DaoFieldsData::class.asTypeName().copy(nullable = true)
        ).mutable()
            .initializer(FIELD_DAO_FIELDS)
            .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
            .build()
        return listOf(
            hyperHiveProviderProp,
            resourceNameProp,
            parameterNameProp,
            isCachedProp,
            isLocalProp
        )
    }

    private fun createRequestFunction(parameters: List<String>): FunSpec.Builder {
        val funcSpec = FunSpec.builder(REQUEST_NAME)
        var mapOfParams = TAG_MEMBER_HALF
        val paramsSize = parameters.size - 1
        val propertyClass = Any::class.asClassName()
        parameters.forEachIndexed { index, paramName ->
            val param = paramName.lowercase()
            val parameterSpec = ParameterSpec.builder(param, propertyClass).build()
            funcSpec.addParameter(parameterSpec)
            mapOfParams += "\"$paramName\" to $param"
            mapOfParams += if (index < paramsSize) ", " else ""
        }
        mapOfParams += ")"

        val replacedParams = FIELD_PARAMS_REPLACE.format(mapOfParams)
        val statement = "$RETURN_STATEMENT ${FUNC_MEMBER_PARAMS_STATEMENT}$replacedParams"
        val returnType = ClassName(MOBRUN_MODEL_PATH, MOBRUN_BASE_NAME)
        val updateFuncName = REQUEST_STATEMENT
        return funcSpec.addStatement(
            statement,
            MemberName(EXTENSIONS_PATH, updateFuncName),
            MemberName(KOTLIN_COLLECTION_PATH, KOTLIN_MAP_OF_NAME)
        ).returns(returnType)
    }

    private fun saveFiles(
        packageName: String,
        classFileName: String,
        builders: List<TypeSpec.Builder>
    ) {
        val file = FileSpec.builder(packageName, classFileName)
            .addComment(FILE_COMMENT)
            .apply {
                builders.forEach { builder ->
                    addType(builder.build())
                }
            }
            .build()
        try {
            file.writeTo(codeGenerator = codeGenerator, dependencies = Dependencies.ALL_FILES)
        } catch (e: IOException) {
            val message = java.lang.String.format("Unable to write file: %s", e.message)
            logger.error(message)
        }
    }

    private fun List<KSAnnotation>.hasAnnotation(name: String): Boolean {
        return findAnnotation(name) != null
    }

    private fun List<KSAnnotation>.findAnnotation(name: String): KSAnnotation? {
        return find { it.annotationType.resolve().declaration.simpleName.asString() == name }
    }

    @Suppress("UNCHECKED_CAST")
    private fun <T : Any> List<KSValueArgument>.getArgumentValue(name: String): T? {
        return firstOrNull { it.name?.asString() == name }?.value as? T
    }

}